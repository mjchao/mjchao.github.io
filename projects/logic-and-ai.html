<!DOCTYPE>
<html>
<body>
    <h1 class="centered-text">Logic and AI</h1>
    <br/>
    <center><img src="images/logic.png"></img></center>
    <h2>Summary</h2>
    <p><b>Goal:</b> Explore algorithms for manipulating and proving statements expressed in first-order logic.</p>
    <p><b>Process:</b>
        <ol>
            <li>Parse an infix logic expression into postfix.</li>
            <li>Convert postfix into tree form.</li>
            <li>Convert tree into conjunctive normal form.</li>
            <li>Apply resolution to prove new statements.</li>
        </ol>
    </p>
    <p><b>Delivered:</b>
        <ol>
            <li>An API that accepts a knowledge base and provides a function to query whether a given statement is true or not necessarily true.</li>
            <li><a href="https://github.com/mjchao/Logic-Based-AI" target="_blank">Project Repository</a>.</li>
        </ol>
    </p>

    <h2>Overview</h2>
    <p>I worked on this project during the winter semester of 2016 and part of my summer break in 2016 before I began my internship at Google. Logic and knowledgebases were my first experience with an artificial intelligence program being able to generalize to different tasks. Of course, the knowledgebase had to be different for each new task, but the algorithms remained the same and generalized.</p>

    <h2>Process</h2>
    <p>My first step was to create the necessary abstractions to parse out tokens in logic expressions. For example, the expression <code>FORALL x f(x)</code>  had to be parsed into the tokens <code>FORALL</code>, <code>x</code>, <code>f</code>, <code>(</code>, <code>x</code>, and <code>)</code>. This was relatively straightforward pattern matching.</p>


    <p>Next, I revisited Dijkstra's Shunting Yard Algorithm for converting infix mathematical expressions to postfix. I made several modifications so that it would take logic operators and deal with quantifiers. The following illustrates one of several subleties with the modifications: consider the infix expression <code>FORALL(x, y) EXISTS z f(x, y, z)</code>. The correct postfix was <code>x y z f EXISTS(z) FORALL(x, y)</code>. We cannot separate <code>EXISTS(z)</code> into two tokens <code>z EXISTS</code> because if the postfix were <code>z f z EXISTS</code> we wouldn't be sure if it represented <code>EXISTS(z) f(z)</code> or <code>EXISTS(z, f(z))</code>.</p>

    <p>The following step is to convert to conjunctive normal form. As presented in Russel and Norvig's <i>Artificial Intelligence A Modern Approach</i> (third edition), the required steps are to
    <ol>
        <li>Eliminate arrows (implications and biconditionals)</li>
        <li>Distribute NOTs inward (specifically, converting to negation-normal form)</li>
        <li>Standardize variable names (two different variables with the same name are treated differently by the system)</li>
        <li>Skolemize existential quantifiers</li>
        <li>Drop universal quantifiers</li>
        <li>Distribute ORs inward over ANDs</li>
    </ol>
    </p>

    <p>Finally, the resolution algorithm runs and tries to unify the negation of the statement to be proven with the knowledgebase. If it reaches any contradiction (i.e. any clause in the conjunctive normal form is False), then the proof by contradiction succeed.</p>

    <p>There were quite a lot of test cases for this project, but there may still be bugs in the system. The system works for simple cases, but may not be as efficient for larger cases. In general though, propositional resolution is still exponential in the worst case. Here is an example of a successful test case:

    <pre><code>
        SymbolTracker tracker = new SymbolTracker();
        tracker.addFunctions( "Person" , "Heart" , "PartOf" , "Living" , "Dead" );
        tracker.addConstants( "Adam" );

        StatementCNF[] kb = new StatementCNF[] {
            StatementCNF.fromInfixString( "FORALL(x) Person(x) => (EXISTS(y) Heart(y) AND PartOf(y,x))" , tracker ) ,
            StatementCNF.fromInfixString( "EXISTS(x) Heart(x) AND PartOf(x,y) => Living(y)" , tracker ) ,
            StatementCNF.fromInfixString( "Person(Adam)" , tracker ) ,
            StatementCNF.fromInfixString( "Dead(x) <=> !Living(x)", tracker )
        };
        StatementCNF hypothesis = StatementCNF.fromInfixString( "Living(Adam)" , tracker );
        Assert.assertTrue( Resolver.proveHypothesis( tracker , hypothesis , kb ) );

        StatementCNF hypothesis2 = StatementCNF.fromInfixString( "Dead(Adam)" , tracker );
        Assert.assertFalse( Resolver.proveHypothesis( tracker , hypothesis2 , kb ) );
    </code></pre>
    </p>

    <p>In the test case, the knowledgebase basically says</p>
    <ol>
        <li>All people have hearts that are part of them.</li>
        <li>If something has a heart that is part of it, then it is living.</li>
        <li>Adam is a person.</li>
        <li>All things that are dead must not be living, and vice versa.</li>
    </ol>
    <p>And we ask the resolver the questions "is Adam living?" and "is Adam dead?" and it correctly answers yes and no.</p>

</body>
</html>
